import isUrl from 'is-url';
import * as fontkit from 'fontkit';

/* eslint-disable max-classes-per-file */
const FONT_WEIGHTS = {
    thin: 100,
    hairline: 100,
    ultralight: 200,
    extralight: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    demibold: 600,
    bold: 700,
    ultrabold: 800,
    extrabold: 800,
    heavy: 900,
    black: 900,
};
const fetchFont = async (src, options) => {
    const response = await fetch(src, options);
    const data = await response.arrayBuffer();
    return new Uint8Array(data);
};
const isDataUrl = (dataUrl) => {
    const header = dataUrl.split(',')[0];
    const hasDataPrefix = header.substring(0, 5) === 'data:';
    const hasBase64Prefix = header.split(';')[1] === 'base64';
    return hasDataPrefix && hasBase64Prefix;
};
const resolveFontWeight = (value) => {
    return typeof value === 'string' ? FONT_WEIGHTS[value] : value;
};
const sortByFontWeight = (a, b) => a.fontWeight - b.fontWeight;
class FontSource {
    src;
    fontFamily;
    fontStyle;
    fontWeight;
    data;
    options;
    loadResultPromise;
    constructor(src, fontFamily, fontStyle, fontWeight, options) {
        this.src = src;
        this.fontFamily = fontFamily;
        this.fontStyle = fontStyle || 'normal';
        this.fontWeight = fontWeight || 400;
        this.data = null;
        this.options = options;
        this.loadResultPromise = null;
    }
    async _load() {
        const { postscriptName } = this.options;
        if (isDataUrl(this.src)) {
            const raw = this.src.split(',')[1];
            const uint8Array = new Uint8Array(atob(raw)
                .split('')
                .map((c) => c.charCodeAt(0)));
            this.data = fontkit.create(uint8Array, postscriptName);
        }
        else if (isUrl(this.src)) {
            const { headers, body, method = 'GET' } = this.options;
            const data = await fetchFont(this.src, { method, body, headers });
            this.data = fontkit.create(data, postscriptName);
        }
        else {
            this.data = await fontkit.open(this.src, postscriptName);
        }
    }
    async load() {
        if (this.loadResultPromise === null) {
            this.loadResultPromise = this._load();
        }
        return this.loadResultPromise;
    }
}
class Font {
    family;
    sources;
    static create(family) {
        return new Font(family);
    }
    constructor(family) {
        this.family = family;
        this.sources = [];
    }
    register({ src, fontWeight, fontStyle, ...options }) {
        const numericFontWeight = resolveFontWeight(fontWeight);
        this.sources.push(new FontSource(src, this.family, fontStyle, numericFontWeight, options));
    }
    resolve(descriptor) {
        const { fontWeight = 400, fontStyle = 'normal' } = descriptor;
        const styleSources = this.sources.filter((s) => s.fontStyle === fontStyle);
        const exactFit = styleSources.find((s) => s.fontWeight === fontWeight);
        if (exactFit)
            return exactFit;
        // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights
        let res;
        const numericFontWeight = resolveFontWeight(fontWeight);
        if (numericFontWeight >= 400 && numericFontWeight <= 500) {
            const leftOffset = styleSources.filter((s) => s.fontWeight <= numericFontWeight);
            const rightOffset = styleSources.filter((s) => s.fontWeight > 500);
            const fit = styleSources.filter((s) => s.fontWeight >= numericFontWeight && s.fontWeight < 500);
            res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
        }
        const lt = styleSources
            .filter((s) => s.fontWeight < numericFontWeight)
            .sort(sortByFontWeight);
        const gt = styleSources
            .filter((s) => s.fontWeight > numericFontWeight)
            .sort(sortByFontWeight);
        if (numericFontWeight < 400) {
            res = lt[lt.length - 1] || gt[0];
        }
        if (numericFontWeight > 500) {
            res = gt[0] || lt[lt.length - 1];
        }
        if (!res) {
            throw new Error(`Could not resolve font for ${this.family}, fontWeight ${fontWeight}, fontStyle ${fontStyle}`);
        }
        return res;
    }
}

var standard = [
    'Courier',
    'Courier-Bold',
    'Courier-Oblique',
    'Courier-BoldOblique',
    'Helvetica',
    'Helvetica-Bold',
    'Helvetica-Oblique',
    'Helvetica-BoldOblique',
    'Times-Roman',
    'Times-Bold',
    'Times-Italic',
    'Times-BoldItalic',
];

class FontStore {
    fonts = {};
    emojiSource = null;
    hyphenationCallback = null;
    register = (data) => {
        const { family } = data;
        if (!this.fonts[family]) {
            this.fonts[family] = Font.create(family);
        }
        // Bulk loading
        if ('fonts' in data) {
            for (let i = 0; i < data.fonts.length; i += 1) {
                this.fonts[family].register({ family, ...data.fonts[i] });
            }
        }
        else {
            this.fonts[family].register(data);
        }
    };
    registerEmojiSource = (emojiSource) => {
        const url = 'url' in emojiSource ? emojiSource.url : undefined;
        const format = 'format' in emojiSource ? emojiSource.format : undefined;
        const builder = 'builder' in emojiSource ? emojiSource.builder : undefined;
        const withVariationSelectors = emojiSource.withVariationSelectors || false;
        this.emojiSource = {
            url,
            format: format || 'png',
            builder,
            withVariationSelectors,
        };
    };
    registerHyphenationCallback = (callback) => {
        this.hyphenationCallback = callback;
    };
    getFont = (descriptor) => {
        const { fontFamily } = descriptor;
        const isStandard = standard.includes(fontFamily);
        if (isStandard)
            return null;
        if (!this.fonts[fontFamily]) {
            throw new Error(`Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`);
        }
        return this.fonts[fontFamily].resolve(descriptor);
    };
    load = async (descriptor) => {
        const { fontFamily } = descriptor;
        const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];
        const promises = [];
        for (let len = fontFamilies.length, i = 0; i < len; i += 1) {
            const family = fontFamilies[i];
            const isStandard = standard.includes(family);
            if (isStandard)
                return;
            const f = this.getFont({ ...descriptor, fontFamily: family });
            promises.push(f.load());
        }
        await Promise.all(promises);
    };
    reset = () => {
        const keys = Object.keys(this.fonts);
        for (let i = 0; i < keys.length; i += 1) {
            const key = keys[i];
            this.fonts[key].data = null;
        }
    };
    clear = () => {
        this.fonts = {};
    };
    getRegisteredFonts = () => this.fonts;
    getEmojiSource = () => this.emojiSource;
    getHyphenationCallback = () => this.hyphenationCallback;
    getRegisteredFontFamilies = () => Object.keys(this.fonts);
}

export { FontStore as default };
